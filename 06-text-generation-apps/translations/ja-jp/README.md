# テキスト生成アプリケーションの構築

[![Building Text Generation Applications](../../images/06-lesson-banner.png?WT.mc_id=academic-105485-yoterada)](https://learn.microsoft.com/_themes/docs.theme/master/en-us/_themes/global/video-embed.html?id=bf3f3528-9871-4628-8616-b4b03cb23dcdt?WT.mc_id=academic-105485-yoterada)

> _(上記の画像をクリックすると、レッスン・ビデオを表示します)_

これまでのレッスンを通じて、プロンプトの基本的な概念や、「プロンプト・エンジニアリング」と呼ぶテクニックについて学んできました。ChatGPT、Office 365、Microsoft Power Platform 　など、プロンプトで操作可能な多くのツールは、皆様が何かを成し遂げるためのサポートを行います。

皆様のアプリケーションに、このような機能を追加するためには、プロンプトや Completion といった概念を理解し、使用するライブラリを選択する必要があります。この章では、それらを具体的に学んでいきます。

## はじめに

このレッスンでは、下記の内容について説明します。

- OpenAI のライブラリとその基本概念について学習します
- OpenAI を使用して、テキスト生成アプリを構築します
- プロンプト、温度、トークンなどの概念を使用してテキスト生成アプリを構築する方法を理解します

## 学習目標

このレッスンを修了すると、下記を理解できます：

- テキスト生成アプリケーションとは何かを説明できる
- OpenAI を使用してテキスト生成アプリを構築する
- 使用するトークン数を増減させたり、温度を変更し、さまざまな出力が得られるようにアプリを構成する

## テキスト生成アプリについて

通常、アプリを作る際、下記のようなインターフェースがあります：

- コマンドベース：コンソール・アプリは典型的な例で、コマンドを入力するとタスクを実行できます。例えば、git はコマンド・ベースのアプリです
- ユーザー・インターフェース（UI）：一部のアプリは、ボタンをクリックしたり、テキストを入力したり、オプションを選択したりするグラフィカル・ユーザーインターフェース（GUI）を持っています。

### コンソールや UI アプリには制限があります

コマンドを入力するコマンド・ベースのアプリと比較してください。

- **入力可能なコマンド数は有限**：任意のコマンドを入力できるわけではなく、アプリがサポートしているコマンドのみ入力可能です。
- **言語特有**：一部のアプリはまれに多言語をサポートしていますが、たとえ追加言語のサポートがされている場合でも、基本的には特定の言語用にアプリは実装されています。

### テキスト生成アプリの利点

それでは、テキスト生成アプリはどう違うのでしょうか?

テキスト生成アプリは、コマンド数や特定の入力言語に制約されず、より柔軟に操作でき、自然言語を使ってアプリと対話できます。さらに、既に大量のテキストや音声データの情報から訓練されたデータ・ソースを利用しているため、従来のアプリがデータベースの内容に限定されるのとは対照的に、利用可能な情報量が大幅に増えます。

### テキスト生成アプリで何が作れるのでしょうか？

作れるものはたくさんあります。例えば：

- **チャットボット**：所属する会社や、提供する製品について質問に答えられるチャットボットは有用です
- **ヘルパー**：LLM は、テキストの要約、テキストから知見の抽出、履歴書作成のように、様々なテキスト生成で利用できます
- **コード・アシスタント**：使用する言語モデルによっては、プログラミング・コードの作成を支援するコード・アシスタントも作れます。例えば、GitHub Copilot や ChatGPT のような製品を使って、コード作成の支援もできます。

## どこから始めればよいのでしょうか？

まず、LLM と統合する方法を理解する必要があります。これには通常、以下の 2 つのアプローチが含まれます：

- API の使用：プロンプトを含む HTTP (RESTful) リクエストを作成し、生成されたテキストを取得
- ライブラリの使用：上記の API 呼び出しより簡単に利用可能で、API 呼び出しを隠蔽したライブラリを使用

## ライブラリ/SDK

LLM を操作するために、いくつかの有名なライブラリがあります：

- **OpenAI** このライブラリを使用すると、モデルに対する接続とプロンプトの送信が簡単になります

また、より高レベルで動作するライブラリもあります：

- **Langchain**：Langchain はよく知られており、Python をサポートしています
- **Semantic Kernel**：Semantic Kernel は、C#、Python、Java をサポートする Microsoft 純正のライブラリです

## OpenAI を使用した最初のアプリ

以降で、最初のアプリを実装する方法、実装に必要なライブラリ、どの位のコード量が必要かなど、ご確認ください。

### OpenAI のインストール

OpenAI や Azure OpenAI と対話するためのライブラリはたくさんあります。また、C#、Python、JavaScript、Java など、さまざまなプログラミング言語で利用可能です。今回は、Python 用の `OpenAI` ライブラリを使用します。そして、ライブラリのインストールには `pip` を使用します。

```bash
pip install openai
```

### リソースの作成

下記の手順に従い操作を行なってください：

- Azure のアカウントを作成します。[https://azure.microsoft.com/free/](https://azure.microsoft.com/free/?WT.mc_id=academic-105485-yoterada)
- Azure Open AI へのアクセス権限を取得します。[https://learn.microsoft.com/azure/ai-services/openai/overview#how-do-i-get-access-to-azure-openai](https://learn.microsoft.com/azure/ai-services/openai/overview#how-do-i-get-access-to-azure-openai?WT.mc_id=academic-105485-yoterada) からアクセス申請を提出します

  > [!NOTE]
  > 本記事の執筆時には、Azure Open AI へのアクセスを申請する必要があります。

- Python をインストールします。 <https://www.python.org/>
- Azure OpenAI Service リソースを作成します。[リソースの作成方法](https://learn.microsoft.com/azure/ai-services/openai/how-to/create-resource?pivots=web-portal?WT.mc_id=academic-105485-yoterada)については、こちらのガイドをご参照ください。

### API キーとエンドポイントを取得

ここで、`OpenAI` ライブラリに対してどの API キーを使用するか指定します。API キーを見つけるためには、Azure OpenAI リソースの「Keys and Endpoint」セクションに移動し、「Key 1」の値をコピーしてください。

![Keys and Endpoint resource blade in Azure Portal](https://learn.microsoft.com/azure/ai-services/openai/media/quickstarts/endpoint.png?WT.mc_id=academic-105485-yoterada)

キーをコピーしたので、それをライブラリで利用できるように指定します。

> [!NOTE]
> API キーはコード中に直接書き込まずに管理すべきです。下記のように環境変数を使用して設定できます。
>
> - 環境変数 `OPENAI_API_KEY` に API キーを設定します  
>   `export OPENAI_API_KEY='sk-...'`

### Azure の設定

Azure OpenAI を使用している場合、下記の設定を追加で行います：

```python
openai.api_type = 'azure'
openai.api_key = os.environ["OPENAI_API_KEY"]
openai.api_version = '2023-05-15'
openai.api_base = os.getenv("API_BASE")
```

上記は、それぞれ下記の設定を行っています：

- `api_type`を`azure`に設定します。これにより、ライブラリは OpenAI ではなく Azure Open AI に接続します。
- `api_key`は、Azure Portal で取得した API キーを設定します。
- `api_version`は、使用する API のバージョンです。執筆時点での最新バージョンは`2023-05-15`です。
- `api_base` は API のエンドポイントです。これは、Azure Portal の API キーの下側に記載されています。

> [!NOTE] > `os.getenv` は環境変数を読み取る関数です。`OPENAI_API_KEY` や `API_BASE` などの環境変数を読み取るために使用します。これらの環境変数は、ターミナルで設定するか、もしくは `dotenv` のようなライブラリを使用して設定します。

> [!NOTE]
> 訳者追記  
> 訳者が確認した所、記載している OpenAI の Python ライブラリが古い 0.28.1 で記載されています。
> 現在はより新しい、OpenAI Python 1.x がリリースされています。
> 新しい 1.x のライブラリへバージョン・アップするため際には、こちらの [Migrating to the OpenAI Python API library 1.x](https://learn.microsoft.com/azure/ai-services/openai/how-to/migration?WT.mc_id=academic-105485-yoterada) をご参照ください

## テキストの生成

`Completion` クラスを使用してテキストを生成する方法をご覧ください。下記にサンプルを記述しています：

```python
prompt = "次の文を完成させてください: むかしむかしある所に"

completion = openai.Completion.create(model="davinci-002", prompt=prompt)
print(completion.choices[0].text)
```

上記のコードでは、Completion オブジェクトを作成し、使用するモデルに対してプロンプトを渡しています。その後、生成されたテキストを出力しています。

### Chat completions

上記では、`Completion` クラスを使用してテキストを生成する方法を見てきました。
しかし、チャット・ボット用には、より適した `ChatCompletion` という別のクラスが用意されています。下記にサンプルを記述しています。

```python
import openai

openai.api_key = "sk-..."

completion = openai.ChatCompletion.create(model="gpt-3.5-turbo", messages=[{"role": "user", "content": "こんにちは世界 (Hello world)"}])
print(completion.choices[0].message.content)
```

この機能の詳細は、次の章で詳しく説明します。

## エクササイズ - 初めてのテキスト生成アプリ

OpenAI のセットアップと設定方法を学んだので、次に初めてのテキスト生成アプリを実装してみましょう。アプリの実装は、下記の手順で行ないます：

1. 仮想環境を作成し、OpenAI をインストールします：

```bash
python -m venv venv
source venv/bin/activate
pip install openai
```

> [!NOTE]
> Windows 環境で行う場合は、`source venv/bin/activate` の代わりに`venv\Scripts\activate` を入力してください。

> [!NOTE]
> Azure OpenAI キーは、[https://portal.azure.com/](https://portal.azure.com/?WT.mc_id=academic-105485-yoterada) から `OpenAI` を検索し、`OpenAI Resource` を選択してください。その後 `Keys and Endpoint` を選択し、`Key 1` の値をコピーてください。

1. _app.py_ ファイルを作成し、下記のコードを記述してください：

```python
import openai

openai.api_key = "<OpenAI のキーまたは Azure OpenAI のキーを入力>"

openai.api_type = 'azure'
openai.api_version = '2023-05-15'
openai.api_base = "<Azure Portal でキーと同一の場所に記載されている接続用エンドポイント>"
deployment_name = "<デプロイ名>"

# ここに Completion コードを追加
prompt = "次の文を完成させてください: むかしむかし、あるところに"

# Completion を作成
completion = openai.Completion.create(engine= deployment_name, model="davinci-002", prompt=prompt)

# レスポンスを出力
print(completion.choices[0].text)
```

> [!NOTE]
> Azure OpenAI を使用している場合、`api_type` として `azure` を設定し、`api_key` に Azure OpenAI キーを設定する必要があります。

下記のような結果が表示されるはずです：

```output
おじいさんとおばあさんが住んでいました。

(※ 上記の回答内容は、訳者が日本語環境での実行にあわせて変更しました。英語で実行した場合と異なる結果が得られます。)
```

## さまざまな種類のプロンプト、さまざまな用途

これまで、プロンプトを使用してテキストを生成する方法を見てきました。色々な種類のテキストを生成するため、今動いているアプリケーションに対して修正・変更を加えテキスト生成機能を追加できます。

プロンプトは様々なタスクに使用できます。例えば：

- **様々なテキストを生成**：詩やクイズの質問などを生成できます
- **情報の検索**：「Web 開発における CORS の意味は何ですか？」のような情報を検索するためにプロンプトを使用できます
- **コード生成**：電子メール・アドレスの検証に使用する正規表現を作成したり、Web アプリケーションのようなプログラム全体のコードを生成するためにプロンプトを使用できます。

## より実用的な使用例：料理レシピの作成

家に食材があって、何か料理を作りたい場合を想像してください。そのためにレシピが必要です。適切なレシピを見つける方法の一つに検索エンジンがありますが、LLM（大規模言語モデル）もレシピを出力できます。

たとえば、下記のようなプロンプトを記述できます：

> 「鶏肉、じゃがいも、にんじん」を使った料理のレシピを 5 つ教えてください。レシピごとに使用する全ての食材をリストしてください。

上記のプロンプトを使用すると、以下のようなレスポンスが得られるかもしれません：

```output
1. ローストチキンと野菜：
材料：
- チキンのもも肉 4 枚
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- オリーブオイル大さじ 2 杯
- にんにく 2 片、みじん切り
- ドライタイム小さじ 1 杯
- ドライオレガノ小さじ 1
- 塩と胡椒、適量

2. チキンとポテトのシチュー：
材料：
- オリーブオイル大さじ 2 杯
- 玉ねぎ 1 個、みじん切り
- にんにく 2 片、みじん切り
- チキンの胸肉 2 枚、角切り
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- ドライオレガノ小さじ 1
- ドライタイム小さじ 1
- チキンブロス 1 カップ
- 塩と胡椒、適量

3. チキンとポテトのベイク：
材料：
- オリーブオイル大さじ 2
- チキンの胸肉 2 枚、角切り
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- 玉ねぎ 1 個、みじん切り
- にんにく 2 片、みじん切り
- ドライオレガノ小さじ 1
- ドライタイム小さじ 1
- チキンブロス 1 カップ
- 塩と胡椒、適量

4. チキンとポテトのスープ：
材料：
- オリーブオイル大さじ2
- 玉ねぎ 1 個、みじん切り
- にんにく 2 片、みじん切り
- チキンの胸肉 2 枚、角切り
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- ドライオレガノ小さじ 1
- ドライタイム小さじ 1
- チキンブロス 4 カップ
- 塩と胡椒、適量

5. チキンとポテトのハッシュ：
材料：
- オリーブオイル大さじ 2
- チキンの胸肉 2 枚、角切り
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- 玉ねぎ 1 個、みじん切り
- にんにく 2 片、みじん切り
- ドライオレガノ小さじ1
```

この結果は素晴らしいですね、食材からどのような料理を作れるかわかりました。ここで役に立つ、改善点２つをご覧ください：

- 好きでない食材やアレルギーのある食材を除外する
- 家に全ての食材がない場合に備え、買い物リストを作成する

上記に対して、追加のプロンプトを作成しましょう：

> "ニンニク・アレルギーがあるので、ニンニクを含むレシピを除外し、別のものに置き換えてください。また、家にはすでに鶏肉、じゃがいも、にんじんがあります、それ以外でレシピに必要な買い物リストを作成してください。"

これで、下記のような新しい結果が得られます

```output
1. ローストチキンと野菜：
材料：
- チキンのもも肉 4 枚
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- オリーブオイル大さじ 2
- ドライタイム小さじ 1
- ドライオレガノ小さじ 1
- 塩と胡椒、適量

2. チキンとポテトのシチュー：
材料：
- オリーブオイル大さじ 2
- 玉ねぎ 1 個、みじん切り
- チキンの胸肉 2 枚、角切り
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- ドライオレガノ小さじ 1
- ドライタイム小さじ 1
- チキンブロス 1 カップ
- 塩と胡椒、適量

3. チキンとポテトのベイク：
材料：
- オリーブオイル大さじ 2
- チキンの胸肉 2 枚、角切り
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- 玉ねぎ 1 個、みじん切り
- ドライオレガノ小さじ 1
- ドライタイム小さじ 1
- チキンブロス 1 カップ
- 塩と胡椒、適量

4. チキンとポテトのスープ：
材料：
- オリーブオイル大さじ 2
- 玉ねぎ 1 個、みじん切り
- チキンの胸肉 2 枚、角切り
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- ドライオレガノ小さじ 1
- ドライタイム小さじ 1
- チキンブロス 4 カップ
- 塩と胡椒、適量

5. チキンとポテトのハッシュ：
材料：
- オリーブオイル大さじ 2
- チキンの胸肉 2 枚、角切り
- じゃがいも 2 個、角切り
- にんじん 2 本、角切り
- 玉ねぎ 1 個、みじん切り
- ドライオレガノ小さじ 1

買い物リスト：
- オリーブオイル
- 玉ねぎ
- タイム
- オレガノ
- 塩
- 胡椒
```

以上が新しい、5 つのレシピで、ニンニクは記載されておらず、家にすでにあるものを考慮し、買い物リストも記載されています。

## 演習 - レシピ作成を構築する

シナリオを一通り試したところで、そのシナリオに合わせたコードを実装してみましょう。下記の手順に従い実装してください。

1. 既存の _app.py_ ファイルを利用します。
2. `prompt`という変数を探し、下記のようにコードを修正してください。

```python
prompt = f"鶏肉、じゃがいも、にんじんを使った料理のレシピを 5 つ教えてください。レシピごとに、使用するすべての食材をリストしてください"
```

コードを実行すると、下記のような結果が表示されます。

```output
-鶏肉とじゃがいも、人参のシチュー: サラダ油大さじ3, 玉ねぎ1個（みじん切り）, ニンニク2片（みじん切り）, 人参1本（皮をむいてみじん切り）, じゃがいも1個（皮をむいてみじん切り）, ローリエ1枚, タイム1枝, 塩小さじ1/2, 黒コショウ小さじ1/4, 鶏ガラスープ1 1/2カップ, ドライホワイトワイン1/2カップ, パセリ（みじん切り）大さじ2, 無塩バター大さじ2, 骨なし鶏もも肉1 1/2ポンド（1インチ角に切る）

-オーブン焼き鶏肉とじゃがいも、人参: エキストラバージンオリーブオイル大さじ3, ディジョンマスタード大さじ1, ローズマリー（みじん切り）大さじ1, タイム（みじん切り）大さじ1, ニンニク4片（みじん切り）, 小さめの赤じゃがいも1 1/2ポンド（4等分に切る）, 人参1 1/2ポンド（縦に4等分に切る）, 塩小さじ1/2, 黒コショウ小さじ1/4, 丸鶏1羽（4ポンド）

-鶏肉、じゃがいも、人参のキャセロール: クッキングスプレー, 大きめの玉ねぎ1個（みじん切り）, ニンニク2片（みじん切り）, 人参1本（皮をむいてみじん切り）, じゃがいも1個（皮をむいてみじん切り）, タイム（乾燥）小さじ1/2, 塩小さじ1/4, 黒コショウ小さじ1/4, 脂肪無添加、低ナトリウムの鶏ガラスープ2カップ, 冷凍グリーンピース1カップ, 中力粉1/4カップ, 低脂肪牛乳1カップ, パルメザンチーズ（おろしたもの）1/4カップ

-ワンポットチキンとじゃがいもディナー: オリーブオイル大さじ2, 骨なし鶏もも肉1ポンド（1インチ角に切る）, 大きめの玉ねぎ1個（みじん切り）, ニンニク3片（みじん切り）, 人参1本（皮をむいてみじん切り）, じゃがいも1個（皮をむいてみじん切り）, ローリエ1枚, タイム1枝, 塩小さじ1/2, 黒コショウ小さじ1/4, 鶏ガラスープ2カップ, ドライホワイトワイン1/2カップ

-鶏肉、じゃがいも、人参のカレー: サラダ油大さじ1, 大きめの玉ねぎ1個（みじん切り）, ニンニク2片（みじん切り）, 人参1本（皮をむいてみじん切り）, じゃがいも1個（皮をむいてみじん切り）, コリアンダー（パウダー）小さじ1, クミン（パウダー）小さじ1, ターメリック（パウダー）小さじ1/2, ジンジャー（パウダー）小さじ1/2, ケイエンペッパー小さじ1/4, 鶏ガラスープ2カップ, ドライホワイトワイン1/2カップ, ヒヨコ豆1缶（15オンス、水切り）, レーズン1/2カップ, シラントロ（みじん切り）1/2カップ
```

> 注意: LLM 　は非決定的(非確実)なので、プログラムを実行するたびに上記とは異なる結果が得られるかもしれません。

さてそれでは、どうすれば改善できるのかを見てみましょう。改善するために、コードに柔軟性を持たせ、材料やレシピの数を変更できるようにします。

1. 以下のようにコードを修正してください。

```python
no_recipes = input("レシピの数を入力してください（例：5）: ")

ingredients = input("食材のリストを入力してください（例：鶏肉、じゃがいも、人参）: ")

# レシピの数と材料をプロンプトに挿入
prompt = f"{ingredients} を使った料理のレシピを {no_recipes} つ教えてください。レシピごとに、使用するすべての食材をリストしてください"
```

このコードを実行すると、下記のような結果が得られます。

```output
レシピの数を入力してください（例：5）: 3
材料のリストを入力してください（例：鶏肉、じゃがいも、人参）: ミルク、イチゴ

-イチゴのミルクシェイク: ミルク、イチゴ、砂糖、バニラエキス、氷
-イチゴのショートケーキ: ミルク、小麦粉、ベーキングパウダー、砂糖、塩、無塩バター、イチゴ、ホイップクリーム
-イチゴミルク: ミルク、イチゴ、砂糖、バニラエキス
```

### フィルターと買い物リストを追加して改善する

上記で、入力に基づいてレシピを生成し、その数や使用する食材を柔軟に変更できるアプリが完成しました。

さらに改善するために、下記の機能を追加したいと思います。

- **材料のフィルタリング**。嫌いな食材やアレルギーのある食材をフィルタリングできるようにしたいと考えています。これを実現するために、既存のプロンプトを編集し、下記のようにフィルター条件をプロンプトの最後に追加してください。

```python
filter = input("フィルター（例：ベジタリアン、ビーガン、グルテンフリー）: ")

prompt = f"{ingredients} を使った料理のレシピを {no_recipes} つ教えてください。レシピごとに、使用するすべての食材をリストしてください。ただし、{filter}は除外してください。"
```

上記では、プロンプトの最後に `{filter}` を追加し、利用者からフィルターの値も取得しています。

プログラムを実行すると、下記のような入出力結果が得られます。

```output
レシピの数を入力してください（例：5）: 3
材料のリストを入力してください（例：鶏肉、じゃがいも、人参）: 玉ねぎ、ミルク
フィルター（例：ベジタリアン、ビーガン、グルテンフリー）: ミルクなし

1. フレンチオニオンスープ
材料:
-大きな玉ねぎ1個、スライス
-ビーフブロス3カップ
-ミルク1カップ
-フレンチブレッド6枚
-パルメザンチーズ、おろしたもの1/4カップ
-バター大さじ1
-乾燥タイム小さじ1
-塩小さじ1/4
-黒コショウ小さじ1/4

作り方:
1. 大きな鍋で、バターで玉ねぎをゴールデンブラウンになるまで炒めます。
2. ビーフブロス、ミルク、タイム、塩、コショウを加えて沸騰させます。
3. 火を弱めて10分間煮ます。
4. スープボウルにフレンチブレッドのスライスを置きます。
5. スープをパンの上にかけます。
6. パルメザンチーズを振りかけます。

2. 玉ねぎとじゃがいものスープ
材料:
-大きな玉ねぎ1個、みじん切り
-じゃがいも2カップ、さいの目に切る
-野菜ブロス3カップ
-ミルク1カップ
-黒コショウ小さじ1/4

作り方:
1. 大きな鍋で、バターで玉ねぎをゴールデンブラウンになるまで炒めます。
2. じゃがいも、野菜ブロス、ミルク、コショウを加えて沸騰させます。
3. 火を弱めて10分間煮ます。
4. 熱々で提供します。

3. クリーミーオニオンスープ
材料:
-大きな玉ねぎ1個、みじん切り
-野菜ブロス3カップ
-ミルク1カップ
-黒コショウ小さじ1/4
-中力粉1/4カップ
-パルメザンチーズ、おろしたもの1/2カップ

作り方:
1. 大きな鍋で、バターで玉ねぎをゴールデンブラウンになるまで炒めます。
2. 野菜ブロス、ミルク、コショウを加えて沸騰させます。
3. 火を弱めて10分間煮ます。
4. 小さなボウルで、中力粉とパルメザンチーズを滑らかになるまで混ぜます。
5. スープに加えてさらに5分間煮ます、またはスープがとろみを帯びるまで。
```

ご覧頂いたの通り、ミルクを含むレシピは全てフィルタリングされています。しかし、もし乳製品を摂取すると体調が悪くなる方であれば、チーズを含むレシピもフィルタリングしたいとお考えになるでしょう。その場合は、明確化にフィルタリングで指示する必要があります。

- **買い物リストを作成** 次に、家にすでにあるものを考慮して、買い物リストを作成したいと考えています。

この機能は、一つのプロンプト内に全てを記述できますし、二つのプロンプトに分けて記述できます。ここでは後者の二つに分けるアプローチを採用します。ここでは、追加のプロンプトを提案していますが、それを機能させるためには、前のプロンプトの結果を後ろのプロンプトのコンテキストに追加する必要があります。

最初のプロンプトの結果を出力するコードを見つけ、下記のコードを追加します：

```python
old_prompt_result = completion.choices[0].text
prompt = "生成されたレシピの買い物リストを作成してください。ただし、すでに持っている食材は含めないでください。"

new_prompt = f"{old_prompt_result} {prompt}"
completion = openai.Completion.create(engine=deployment_name, prompt=new_prompt, max_tokens=1200)

# レスポンスを出力
print("買い物リスト:")
print(completion.choices[0].text)
```

以下の点にご注意ください：

1. 最初のプロンプトの結果を新しいプロンプトに追加して、新しいプロンプトを作成します：

```python
new_prompt = f"{old_prompt_result} {prompt}"
```

1. 新しいリクエストを作成しますが、最初のプロンプトで要求したトークン数も考慮に入れて、今回は `max_tokens` を 1200 とします。

```python
completion = openai.Completion.create(engine=deployment_name, prompt=new_prompt, max_tokens=1200)
```

このコードを実行すると、下記のような結果が得られます：

```output
レシピの数（例えば、5）: 2
食材のリスト（例えば、チキン、ポテト、キャロット）: リンゴ、小麦粉
フィルター（例えば、ベジタリアン、ビーガン、グルテンフリー）: 砂糖

-リンゴと小麦粉のパンケーキ: 小麦粉1カップ、ベーキングパウダー1/2小さじ、ベーキングソーダ1/2小さじ、塩1/4小さじ、砂糖1大さじ、卵1個、バターミルクまたはサワーミルク1カップ、溶かしたバター1/4カップ、皮を剥いてすりおろしたグラニースミスリンゴ1個
-リンゴのフリッター: 小麦粉1-1/2カップ、ベーキングパウダー1小さじ、塩1/4小さじ、ベーキングソーダ1/4小さじ、ナツメグ1/4小さじ、シナモン1/4小さじ、オールスパイス1/4小さじ、砂糖1/4カップ、植物性ショートニング1/4カップ、ミルク1/4カップ、卵1個、皮を剥いて細かく刻んだリンゴ2カップ

買い物リスト:
-小麦粉、ベーキングパウダー、ベーキングソーダ、塩、砂糖、卵、バターミルク、バター、リンゴ、ナツメグ、シナモン、オールスパイス
```

> [!NOTE]
> 訳者追記  
> 上記の買い物リストの結果は、自宅にある食材（リンゴ、小麦粉）も含まれています。これらを除外するには、プロンプトを修正する必要があります。これは追加課題として、ご自身で実装してみてください。

## セットアップを改善しましょう

現状で、動作するコードができていますが、さらに改善するためにはいくつかの調整が必要です。以下に、改善すべき点をいくつか挙げてみます。

- **API キーの機密情報をコードから分離する**　機密情報はコードに含めるべきではなく、安全な場所に保存すべきです。機密情報をコードから分離するために、環境変数や `python-dotenv` のようなライブラリを使ってファイルから読み込めます。実装は下記のようになります：

1. 下記の内容を含む `.env` ファイルを作成します：

```bash
OPENAI_API_KEY=sk-...
```

> ご注意：Azure を使用する場合は、下記の環境変数を設定する必要があります：

```bash
OPENAI_API_TYPE=azure
OPENAI_API_VERSION=2023-05-15
OPENAI_API_BASE=<replace>
```

コード上では、下記のように記述し環境変数から読み込めます：

```python
from dotenv import load_dotenv

load_dotenv()

openai.api_key = os.environ["OPENAI_API_KEY"]
```

- **トークンの長さ** 生成するテキストに必要なトークン数を考慮してください。トークンは増えれば増えるほど費用がかかるため、可能な限りトークン数を節約するようにしましょう。例えば、プロンプトをどのように表現すればトークンを少なくできるかご検討ください。

扱うトークン数を変更するには、`max_tokens` パラメータを使用します。例えば、100 トークンを使用したい場合は、以下のようにします：

```python
completion = openai.Completion.create(model="davinci-002", prompt=prompt, max_tokens=100)
```

- **温度 (Temperature)** これまで触れていなかった温度ですが、プログラムの実行結果に大きな影響を与えます。温度が高いほど（値が 1 に近いほど）、出力はランダムになります。逆に、温度値が低いほど(値が 0 に近いほど)、出力結果は予測可能になります。ご自身のアプリで出力にバリエーションが必要かどうかを考えてください。

温度を変更するには、`temperature` パラメータを使用します。例えば、温度を 0.5 に設定したい場合は、以下のようにします：

```python
completion = openai.Completion.create(model="davinci-002", prompt=prompt, temperature=0.5)
```

> 注意：1.0 に近づくほど、出力のバリエーションが大きくなります。

## 課題

この課題で何を作るかは任意です。

下記にいくつかの例を挙げます：

- レシピ生成アプリを微調整してさらに改善しましょう。温度の値やプロンプトを変えて、どのような結果が得られるかお試しください。
- 「勉強仲間」を作ってみましょう。このアプリは、例えば Python に関する質問に対して答えます。「Python の "特定のトピック" は何ですか？」といったプロンプトを受け付けたり、「"特定のトピック" に関するコードを教えてください」といったプロンプトを受け付けられます。
- 「歴史ボット」を作って、歴史を鮮やかに再現してみましょう。ボットに特定の歴史的人物を演じさせ、その人物の生涯やその時代について質問してみましょう。

## 解法

### 勉強仲間

下記は、あくまでも参考のプロンプトですので、使い方を確認し、お好みに合わせて微調整してください。

```text
- "あなたは Python 言語のエキスパートです

下記の形式で Python の初心者用レッスンを提案してください：

形式：
    - 概念：
    - レッスンの簡単な説明：
    - 解答付きのコード演習"
```

### 歴史ボット

ここで、使用できるプロンプトをいくつか紹介します。

```text
- "あなたはエイブラハム・リンカーンです。あなたご自身について 3 つの文章を使って教えてください、そしてエイブラハムが使ったであろう文法と言葉を使って答えてください"
- "あなたはエイブラハム・リンカーンです。エイブラハムが使ったであろう文法と言葉を使って答えてください：

   あなたの最大の功績について、300文字で教えてください"
```

## 知識チェック

概念「温度」は何を行うのでしょうか？

1. 出力のランダム性を制御します。
2. 応答の規模を制御します。
3. 使用するトークンの数を制御します。

## 🚀 チャレンジ

課題に取り組む際、温度を 0、0.5、1 に変えて設定してみてください。0 が最も変化が少なく、1 が最も大きくなります。ぜひ覚えておいてください、皆様のアプリにとって最適な値は何ですか?

## お疲れ様でした!　学習を続ける

このレッスン修了後、[生成 AI 学習コレクション](https://aka.ms/genai-collection?WT.mc_id=academic-105485-yoterada) をチェックして、Generative AI の知識をレベルアップさせましょう。

レッスン 7 では、[チャットアプリケーションの構築](../../../07-building-chat-applications/translations/ja-jp/README.md?WT.mc_id=academic-105485-yoterada)方法を見ていきます。
